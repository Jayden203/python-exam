# ==============================
# Programming and Systems Development - Final Lab Exam
# Author: Your Name
# File: your_name_python_task.py
# ==============================

import pandas as pd
import sqlite3
import matplotlib.pyplot as plt
import torch
import torch.nn as nn
import torch.optim as optim

# ------------------------------
# Task 1: Python Basics and Data Manipulation
# ------------------------------

# 1a: Load and preprocess data
df = pd.read_csv('sales_data.csv')

# Fill missing values with appropriate defaults
df['Product'].fillna('Unknown', inplace=True)
df['Quantity'].fillna(0, inplace=True)
df['Price'].fillna(df['Price'].mean(), inplace=True)
df['Total'].fillna(df['Quantity'] * df['Price'], inplace=True)

# Convert Date to datetime
df['Date'] = pd.to_datetime(df['Date'], errors='coerce')

# Ensure Total = Quantity * Price
df['Computed_Total'] = df['Quantity'] * df['Price']
df.loc[df['Total'] != df['Computed_Total'], 'Total'] = df['Computed_Total']
df.drop(columns=['Computed_Total'], inplace=True)

print("âœ… Data cleaned and loaded successfully!")

# 1b: Data Visualization
# Bar chart: total quantity sold per product
product_sales = df.groupby('Product')['Quantity'].sum()
product_sales.plot(kind='bar', title='Total Quantity Sold per Product')
plt.xlabel('Product')
plt.ylabel('Total Quantity')
plt.tight_layout()
plt.show()

# Line plot: total sales over time (2023)
df_2023 = df[df['Date'].dt.year == 2023]
monthly_sales = df_2023.groupby(df_2023['Date'].dt.to_period('M'))['Total'].sum()
monthly_sales.plot(kind='line', marker='o', title='Monthly Sales Trend (2023)')
plt.xlabel('Month')
plt.ylabel('Total Sales')
plt.tight_layout()
plt.show()

# ------------------------------
# Task 2: Database Management (SQLite)
# ------------------------------

# 2a: Create database and table
conn = sqlite3.connect('SalesDB.db')
cursor = conn.cursor()

cursor.execute('''
CREATE TABLE IF NOT EXISTS Sales (
    Date TEXT,
    Product TEXT,
    Quantity INTEGER,
    Price REAL,
    Total REAL,
    PRIMARY KEY (Date, Product)
)
''')

# Insert data (avoid duplicates)
for _, row in df.iterrows():
    cursor.execute('''
    INSERT OR IGNORE INTO Sales (Date, Product, Quantity, Price, Total)
    VALUES (?, ?, ?, ?, ?)
    ''', (str(row['Date']), row['Product'], int(row['Quantity']), float(row['Price']), float(row['Total'])))

conn.commit()
print("âœ… Data inserted into SalesDB successfully!")

# 2b: Queries
# Total Sales for 2023
cursor.execute("""
SELECT SUM(Total) FROM Sales WHERE strftime('%Y', Date) = '2023'
""")
total_sales_2023 = cursor.fetchone()[0]
print(f"ðŸ’° Total Sales in 2023: {total_sales_2023:.2f}")

# Product Sales Summary
cursor.execute("""
SELECT Product, SUM(Quantity) AS TotalQuantity
FROM Sales
WHERE strftime('%Y', Date) = '2023'
GROUP BY Product
ORDER BY TotalQuantity DESC
""")
print("ðŸ“Š Product Sales Summary (2023):")
for product, qty in cursor.fetchall():
    print(f"{product}: {qty}")

conn.close()

# ------------------------------
# Task 3: Simple Neural Network (PyTorch)
# ------------------------------

# 3a: Model definition
class SimpleNN(nn.Module):
    def __init__(self):
        super(SimpleNN, self).__init__()
        self.fc1 = nn.Linear(10, 5)
        self.fc2 = nn.Linear(5, 3)
        self.fc3 = nn.Linear(3, 1)
        self.relu = nn.ReLU()
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        x = self.relu(self.fc1(x))
        x = self.relu(self.fc2(x))
        x = self.sigmoid(self.fc3(x))
        return x

# Initialize model, loss, optimizer
model = SimpleNN()
criterion = nn.MSELoss()
optimizer = optim.SGD(model.parameters(), lr=0.01)

# 3b: Generate synthetic data
X = torch.randn(100, 10)
y = torch.randn(100, 1)

# 3c: Train the network
losses = []
for epoch in range(20):
    optimizer.zero_grad()
    outputs = model(X)
    loss = criterion(outputs, y)
    loss.backward()
    optimizer.step()
    losses.append(loss.item())
    print(f"Epoch {epoch+1}/20 - Loss: {loss.item():.4f}")

# 3d: Plot loss over epochs
plt.plot(range(1, 21), losses, marker='o')
plt.title('Training Loss Over Epochs')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.grid(True)
plt.show()
